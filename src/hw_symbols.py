from sympy import symbols, ceiling


C_tr = symbols("C_tr", positive=True)
R_tr = symbols("R_tr", positive=True)
V_dd = symbols("V_dd", positive=True)
f = symbols("f", positive=True)
I_leak = symbols("I_leak", positive=True)

latency_tr_wc = R_tr * C_tr
power_tr_act = C_tr * (V_dd ** 2) * f
power_tr_pass = I_leak * V_dd

nsw = {
    "And": symbols("nsw_And"),
    "Or": symbols("nsw_Or"),
    "Add": symbols("nsw_Add"),
    "Sub": symbols("nsw_Sub"),
    "Mult": symbols("nsw_Mul"),
    "FloorDiv": symbols("nsw_FloorDiv"),
    "Mod": symbols("nsw_Mod"),
    "LShift": symbols("nsw_LShift"),
    "RShift": symbols("nsw_RShift"),
    "BitOr": symbols("nsw_BitOr"),
    "BitXor": symbols("nsw_BitXor"),
    "BitAnd": symbols("nsw_BitAnd"),
    "Eq": symbols("nsw_Eq"),
    "NotEq": symbols("nsw_NotEq"),
    "Lt": symbols("nsw_Lt"),
    "LtE": symbols("nsw_LtE"),
    "Gt": symbols("nsw_Gt"),
    "GtE": symbols("nsw_GtE"),
    "USub": symbols("nsw_USub"),
    "UAdd": symbols("nsw_UAdd"),
    "IsNot": symbols("nsw_IsNot"),
    "Not": symbols("nsw_Not"), 
    "Invert": symbols("nsw_Invert"),
    "Regs": symbols("nsw_Regs")
}

nt = {
    "And": symbols("nt_And"),
    "Or": symbols("nt_Or"),
    "Add": symbols("nt_Add"),
    "Sub": symbols("nt_Sub"),
    "Mult": symbols("nt_Mul"),
    "FloorDiv": symbols("nt_FloorDiv"),
    "Mod": symbols("nt_Mod"),
    "LShift": symbols("nt_LShift"),
    "RShift": symbols("nt_RShift"),
    "BitOr": symbols("nt_BitOr"),
    "BitXor": symbols("nt_BitXor"),
    "BitAnd": symbols("nt_BitAnd"),
    "Eq": symbols("nt_Eq"),
    "NotEq": symbols("nt_NotEq"),
    "Lt": symbols("nt_Lt"),
    "LtE": symbols("nt_LtE"),
    "Gt": symbols("nt_Gt"),
    "GtE": symbols("nt_GtE"),
    "USub": symbols("nt_USub"),
    "UAdd": symbols("nt_UAdd"),
    "IsNot": symbols("nt_IsNot"),
    "Not": symbols("nt_Not"), 
    "Invert": symbols("nt_Invert"),
    "Regs": symbols("nt_Regs")
}

gamma = {
    "And": symbols("gamma_And"),
    "Or": symbols("gamma_Or"),
    "Add": symbols("gamma_Add"),
    "Sub": symbols("gamma_Sub"),
    "Mult": symbols("gamma_Mul"),
    "FloorDiv": symbols("gamma_FloorDiv"),
    "Mod": symbols("gamma_Mod"),
    "LShift": symbols("gamma_LShift"),
    "RShift": symbols("gamma_RShift"),
    "BitOr": symbols("gamma_BitOr"),
    "BitXor": symbols("gamma_BitXor"),
    "BitAnd": symbols("gamma_BitAnd"),
    "Eq": symbols("gamma_Eq"),
    "NotEq": symbols("gamma_NotEq"),
    "Lt": symbols("gamma_Lt"),
    "LtE": symbols("gamma_LtE"),
    "Gt": symbols("gamma_Gt"),
    "GtE": symbols("gamma_GtE"),
    "USub": symbols("gamma_USub"),
    "UAdd": symbols("gamma_UAdd"),
    "IsNot": symbols("gamma_IsNot"),
    "Not": symbols("gamma_Not"), 
    "Invert": symbols("gamma_Invert"),
    "Regs": symbols("gamma_Regs")
}

symbolic_latency_wc = {
    "And": gamma["And"] * latency_tr_wc,
    "Or": gamma["Or"] * latency_tr_wc,
    "Add": gamma["Add"] * latency_tr_wc,
    "Sub": gamma["Sub"] * latency_tr_wc,
    "Mult": gamma["Mult"] * latency_tr_wc,
    "FloorDiv": gamma["FloorDiv"] * latency_tr_wc,
    "Mod": gamma["Mod"] * latency_tr_wc,
    "LShift": gamma["LShift"] * latency_tr_wc,
    "RShift": gamma["RShift"] * latency_tr_wc,
    "BitOr": gamma["BitOr"] * latency_tr_wc,
    "BitXor": gamma["BitXor"] * latency_tr_wc,
    "BitAnd": gamma["BitAnd"] * latency_tr_wc,
    "Eq": gamma["Eq"] * latency_tr_wc,
    "NotEq": gamma["NotEq"] * latency_tr_wc,
    "Lt": gamma["Lt"] * latency_tr_wc,
    "LtE": gamma["LtE"] * latency_tr_wc,
    "Gt": gamma["Gt"] * latency_tr_wc,
    "GtE": gamma["GtE"] * latency_tr_wc,
    "USub": gamma["USub"] * latency_tr_wc,
    "UAdd": gamma["UAdd"] * latency_tr_wc,
    "IsNot": gamma["IsNot"] * latency_tr_wc,
    "Not": gamma["Not"] * latency_tr_wc,
    "Invert": gamma["Invert"] * latency_tr_wc,
    "Regs": gamma["Regs"] * latency_tr_wc,
}

symbolic_latency_cyc = {
    "And": ceiling(f*symbolic_latency_wc["And"]) / f,
    "Or": ceiling(f*symbolic_latency_wc["Or"]) / f,
    "Add": ceiling(f*symbolic_latency_wc["Add"]) / f,
    "Sub": ceiling(f*symbolic_latency_wc["Sub"]) / f,
    "Mult": ceiling(f*symbolic_latency_wc["Mult"]) / f,
    "FloorDiv": ceiling(f*symbolic_latency_wc["FloorDiv"]) / f,
    "Mod": ceiling(f*symbolic_latency_wc["Mod"]) / f,
    "LShift": ceiling(f*symbolic_latency_wc["LShift"]) / f,
    "RShift": ceiling(f*symbolic_latency_wc["RShift"]) / f,
    "BitOr": ceiling(f*symbolic_latency_wc["BitOr"]) / f,
    "BitXor": ceiling(f*symbolic_latency_wc["BitXor"]) / f,
    "BitAnd": ceiling(symbolic_latency_wc["BitAnd"]) / f,
    "Eq": ceiling(f*symbolic_latency_wc["Eq"]) / f,
    "NotEq": ceiling(f*symbolic_latency_wc["NotEq"]) / f,
    "Lt": ceiling(f*symbolic_latency_wc["Lt"]) / f,
    "LtE": ceiling(f*symbolic_latency_wc["LtE"]) / f,
    "Gt": ceiling(f*symbolic_latency_wc["Gt"]) / f,
    "GtE": ceiling(f*symbolic_latency_wc["GtE"]) / f,
    "USub": ceiling(f*symbolic_latency_wc["USub"]) / f,
    "UAdd": ceiling(f*symbolic_latency_wc["UAdd"]) / f,
    "IsNot": ceiling(f*symbolic_latency_wc["IsNot"]) / f,
    "Not": ceiling(f*symbolic_latency_wc["Not"]) / f,
    "Invert": ceiling(f*symbolic_latency_wc["Invert"]) / f,
    "Regs": ceiling(f*symbolic_latency_wc["Regs"]) / f,
}

symbolic_power_active = {
    "And": nsw["And"] * power_tr_act,
    "Or": nsw["Or"] * power_tr_act,
    "Add": nsw["Add"] * power_tr_act,
    "Sub": nsw["Sub"] * power_tr_act,
    "Mult": nsw["Mult"] * power_tr_act,
    "FloorDiv": nsw["FloorDiv"] * power_tr_act,
    "Mod": nsw["Mod"] * power_tr_act,
    "LShift": nsw["LShift"] * power_tr_act,
    "RShift": nsw["RShift"] * power_tr_act,
    "BitOr": nsw["BitOr"] * power_tr_act,
    "BitXor": nsw["BitXor"] * power_tr_act,
    "BitAnd": nsw["BitAnd"] * power_tr_act,
    "Eq": nsw["Eq"] * power_tr_act,
    "NotEq": nsw["NotEq"] * power_tr_act,
    "Lt": nsw["Lt"] * power_tr_act,
    "LtE": nsw["LtE"] * power_tr_act,
    "Gt": nsw["Gt"] * power_tr_act,
    "GtE": nsw["GtE"] * power_tr_act,
    "USub": nsw["USub"] * power_tr_act,
    "UAdd": nsw["UAdd"] * power_tr_act,
    "IsNot": nsw["IsNot"] * power_tr_act,
    "Not": nsw["Not"] * power_tr_act,
    "Invert": nsw["Invert"] * power_tr_act,
    "Regs": nsw["Regs"] * power_tr_act,
}

symbolic_power_passive = {
    "And": nt["And"] * power_tr_pass,
    "Or": nt["Or"] * power_tr_pass,
    "Add": nt["Add"] * power_tr_pass,
    "Sub": nt["Sub"] * power_tr_pass,
    "Mult": nt["Mult"] * power_tr_pass,
    "FloorDiv": nt["FloorDiv"] * power_tr_pass,
    "Mod": nt["Mod"] * power_tr_pass,
    "LShift": nt["LShift"] * power_tr_pass,
    "RShift": nt["RShift"] * power_tr_pass,
    "BitOr": nt["BitOr"] * power_tr_pass,
    "BitXor": nt["BitXor"] * power_tr_pass,
    "BitAnd": nt["BitAnd"] * power_tr_pass,
    "Eq": nt["Eq"] * power_tr_pass,
    "NotEq": nt["NotEq"] * power_tr_pass,
    "Lt": nt["Lt"] * power_tr_pass,
    "LtE": nt["LtE"] * power_tr_pass,
    "Gt": nt["Gt"] * power_tr_pass,
    "GtE": nt["GtE"] * power_tr_pass,
    "USub": nt["USub"] * power_tr_pass,
    "UAdd": nt["UAdd"] * power_tr_pass,
    "IsNot": nt["IsNot"] * power_tr_pass,
    "Not": nt["Not"] * power_tr_pass,
    "Invert": nt["Invert"] * power_tr_pass,
    "Regs": nt["Regs"] * power_tr_pass,
}